<!--😎😎오픈 그래프와 트위터 카드😎😎-->
1) 오픈 그래프(The Open Graph protocol)💗
: 웹페이지가 소셜 미디어(페이스북 등)으로 공유될 때 우선적으로 활용되는 정보 지정
 1-1) 웹페이지가 공유되는 개념
 ex)  카카오톡에다가 특정한 웹사이트의 주소를 입력해서 
    전송하는 경우, 해당하는 주소의 정보가 '카드형식'으로 많이 
    나타남 
=>   웹페이지가 소셜미디어로 공유된다는 것 : 해당하는 웹페이지의 링크를 카카오톡같은 
     메신저같은 곳에 공유할 때 오픈그래프 개념이 사용됨
=>   대표적으로 카카오톡의 경우, 주소를 메시지로 입력해서 전송을 하게 되면, 카카오톡 내부에서
     페이지에 접속해서 사용자들이 볼 수 있는 최소한의 메타정보만 끌어다가 사이트의 이름이 무엇인지,
     기본적인 설명은 무엇인지, 로고는 무엇인지 표시를 할 수 있는 기능이 들어있음 
=>   메신저가 중요한 정보만 가져가는 것으로, 중요한 정보를 우선적으로 제공할 수 있도록
     💞오픈그래프💞라는 형태로 해당하는 정보를 취급해주면 됨
 1-2) 오픈그래프(og) 작성방법
  💚 og:type - 페이지의 유형(ex) website, video.movie)
  <meta property="og:type" content="website"/>
  💚 og:site_name - 속한 사이트의 이름
  <meta property="og:site_name" content="Starbucks"/>
  💚 og:title - 페이지의 이름(제목)
  <meta property="og:title" content="Starbucks Coffee Korea">
  💚 og:description - 페이지의 간단한 설명
  <meta property="og:description" content="스타벅스는 세계에서 가장 큰 다국적 커피 전문점입니다.">
  💚 og: image - 페이지의 대표 이미지 주소(URL)
  <meta property="og:image" content="./images/starbucks_seo.jpg"/>
  💚 og: url - 페이지 주소URL
  <meta property="og:url" content="https://starbucks.co.kr"/>
  ====> title태그, link태그, script태그, style태그 같이 역할이 명확한
        정보를 나타내는 태그들을 제외하고, 나머지 정보들은 meta태그로 표시
  ====> 따라서 meta 태그를 이용해서 다양한 정보들을 다양한 상황에서 활용할 수 있음

2) 트위터 카드(Twitter Cards)
: 웹페이지가 소셜미디어(트위터)로 공유될 때 우선적으로 활용되는 정보를 지정
 💚 twitter:card - 페이지(카드)의 유형(ex) Summary, player)
 <meta property="twitter:card" content="summary"/>
 💚 twitter:site - 속한 사이트의 이름
 <meta property="twitter:site" contents="Starbucks"/>
 💚 twitter:title - 페이지의 이름(제목)
 <meta property="twitter:title" content="Starbucks Coffee Korea"/>
 💚 twitter:description - 페이지의 간단한 설명
 <meta property="twitter:description" content="스타벅스는 세계에서 가장 큰 다국적 커피 전문점입니다">
 💚 twitter:image - 페이지의 대표 이미지 주소(URL)
 <meta property="twitter:image" content="./images/starbucks_seo.jpg"/> 
 💚 twitter:url - 페이지 주소(URL)
 <meta property="twitter:url" content="https://starbucks.co.kr"/>

💥외부에서 접속해서 빨리 파악해야 하는 정보들은 head태그에 상단에 작성
💥image에서 SEO(검색 엔진 최적화, Search Engine Optimization)
: 구글이나 네이버 등에 자신의 웹 사이트/ 페이지를 노출할 수 있도록 
  정보를 최적화하는 작업을 말함

<!--😎😎3. 시작하기 - Google Fonts😎😎--> 
: 폰트의 서체가 브라우저마다 다름
: 폰트 용량이 굉장히 큼
=> 따라서, 하나의 페이지에서 폰트 남발 X
❗CSS선언방식❗
 💞 <link>방식 - 병렬방식(html에서 외부에 있는 CSS를 가져오는 방식)
 💞 @import 방식 - 직렬로 CSS파일에서 외부에 있는 CSS를 가져오는 방식
    (대부분은 link방식 사용)

<!--😎😎4. 시작하기 - Google Material Icons😎😎-->
1. Google material Icons 가이드라인 접속
=>https://google.github.io/material-design-icons/
2. Setup Method 1. Using via Google Web Fonts 부근에서 link복사
3. 하고싶은 icon찾아서 복붙하기
4. 작동이 되지 않는다면 복사한 link 뒤에 +outlined 적어넣기

<!--😎😎헤더와 드롭다운 메뉴😎😎-->
헤더- 로고 + 서브메뉴 + 메뉴
💥div로만 태그 작성하지 말 것.
  div로만 작성하면 html만 봤을 때 영역 구분을 알아보기가 어려움
=> 헤더부분의 경우에는 <header></header> 태그 사용
💥 <a href="/"> <!--="도메인/index.html"-->  
=> / = 메인페이지로 이동하겠다.(index.html)
💥웹페이지의 기본 폰트 컬러를 '검정색'으로 하면 촌스러워보일 수 있기 때문에,
  검정색보다 연한 색으로 지정해줌
  여기에서는 다크그레이 색상인 #333333;을 지정함
💥 body부분에 line-height 지정하여 글이 여러줄이 될 때, 사용자에게 답답함을 
   주지 않기 위해서 행간을 제공
   여기에서는 폰트크기(16px)의 1.4배의 행간을 제공했음
❤header 중앙정렬 방법❤
1. 일단 header태그와 header inner태그에 각각 색상부여
  (정렬이 어떻게 되어있는지 보기 위함)
2. 화면을 축소해서 보면, header innder태그가 왼쪽에 치우쳐있음을 알 수 있음
3. header inner을 중앙정렬하기 위해서 inner태그에 margin: 0 auto를 부여해서
   양 옆값을 브라우저가 자동으로 위치할 수 있도록 함
   => header의 중앙으로 정렬됨
==> 이렇게 아이템을 넣고자 하는 영역을 중앙정렬시키는게
    대부분의 웹사이트에서 실행하고 있는 방식임

🤍헤더안에 넣은 로고는 height값이 75px.
  그런데 header inner의 영역이 로고의 크기보다 살짝 초과하는 이유🤍
  1) <img/> = 인라인 요소 (가로세로값 X margin/padding의 위 아래값을 가질 수 X-글자를 다루는 요소)
            = baseline: 문자/글자의 아랫쪽의 기준이 되는 선
            = 기본적으로 글자는 baseline이 존재.
              글자요소인 inline태그들은 모두 baseline을 기준으로 아랫쪽에 약간의 공간을 가질 수 있는 구조를
              가지고 있음  
  => 따라서 그 간격을 없애기 위해 img태그의 display를 block요소로 바꾸어줌
     (로고 아래에 있는 공간이 사라짐!)

🤍부모요소 안에 자식요소를 수직중앙, 또는 수평정렬하는 방법
1. 자식요소에 부모요소 안에서 정렬될 수 있도록 position: absolute 지정
2. 부모요소 지정을 위해 position:relative 지정
3. 수직정렬을 위해서 자식요소의 정확한 높이값을 적어줌(ex) height:75px)
4. 그 높이의 양 끝점을 부여(top:0 / bottom:0)
5. margin:auto 0을 부여하여 브라우저가 제시된 높이의 양 끝점을 기준으로 중앙정렬 할 수 있도록 해줌
6. 수평정렬시에는 width값 지정, left/right 양 끝점인 0 지정,
   margin:0 auto 부여로 브라우저에게 중앙정렬을 맡김     

<!--😎😎6.헤더와 드롭다운 메뉴- 서브메뉴😎😎-->
*javascript:void(0) : JS를 통해서 어떤 기능을 동작시킬건데, 그 동작이 void.
                      즉, 아무것도 없다는 뜻 
                     : javascript:void(0)는 아무것도 동작하지 않음
                       반면에 #은 페이지에 약간의 변화가 있을 수 있음
                       (#은 hash라는 특정한 기능을 갖고 있기 때문)
* css작성 팁: html구조를 우선 옮겨넣은 후에 css작성이 더 깔끔하고 헷갈리지 않음
* a태그 css팁 : 사용자들이 태그 주변부를 클릭해도 다른 링크로 이동할 수 있도록 padding값을 11px-10px정도 줌
                display요소를 block으로 변경.

💥position을 absolute로 설정하면 display가 자동으로 block요소로 변함

<!--😎😎07. 헤더와 드롭다운 메뉴 - 검색😎😎-->
🤍:focus
: input박스를 눌렀을 때의(focus) 효과를 지정할 수 있도록 해주는 가상클래스선택자
ex) 검색창을 focus했을 때 검색창의 너비를 늘리고 싶다면?
    search:focus{
      width:190px;
    }
🤍 sub메뉴와 search를 같은 라인에 올리기 위해서 그 둘을 감싸고 있는
    .sub menu에 display: flex을 적음
  => search가 sub-menu 위치하게 되면서 검색창과 검색아이콘이 하나로 겹쳐짐
  => 문제는 search 아이콘을 누르면 반응이 없다는 것 + 검색창이 focus되면 icon이 감춰져야
     한다는 것
     : icon에는 focuse를 적용하지 않았기 때문에 반응이 없음
     : 따라서 icon을 누르면 반응을 하게끔 만들어야 하는데, 그건 JS 역할임
 🤍Search ICON JS
 1. 찾아야 할 요소 찾기(document.querySelector)  
 => search 태그부분 찾기 + search 태그 안에 input요소 찾기  
 const searchEl = document.querySelector('.search');
 const searchInputEl = searchEl.querySelector('.search input');
 ✔ 이미 첫번째에 search 태그를 찾았기 때문에, input요소를 찾는 두번째 변수에는
    document 자리에 첫번째 변수이름을 대신 적어주면 된다.
    (따라서 document는 하나의 '요소'로 보면 되고, document는 HTML로 보면 된다.)
  
  2. search 요소에 'clcik' 이벤트 추가하기(addEventListener)
  => 그 다음 click이벤트를 처리하는 함수(handler)를 넣고, 그 안에 어떤 것을 처리할 건지 씀
     :  searchInputEl요소를 focus 하겠다는 명령 실행)
     searchEl.addEventListener('click',function(){
      //logic
      searchInputEl.focus();
    });
 =>  결과 : input요소에 소속되어있는 search 클래스를 가지고 있는 div요소 아무곳이나 click 해도
            focus가 잘 된다  
  3. searchInputEl에도 addEventListene()추가
  => 'focus' event를 이용
  (searchInputEl, 즉 input요소를 focus하면 searchEl에 'focused'라는 class가 추가되도록)
  searchInputEl.addEventListener('focus', function(){
    searchEl.classList.add('focused');
  });
  => 이렇게 class를 추가하는 이유?
  : css를 통해서 선택자가 무엇이 추가되었을 때 스타일을 어떻게 바꾸겠다! 를 
    선언해줄 수 있음 

  + 추가로 searchInputEl에서가 setAttribute()라는 메소드 추가
    (setAttribute: set - 무엇인가를 지정한다 / Attribute - HTML의 속성
                       - 즉, HTML속성을 지정할 때 쓰는 메소드 )
    searchInputEl.addEventListener('focus', function(){
    searchEl.classList.add('focused');
    searchInputEl.setAttribute('placeholder','통합검색');
    <!-- setAttribute('속성의 이름','속성에 들어갈 실제 값')
    =<input placeholder="통합검색>   -->
  });   
  
  4. 반대에 해당하는, 즉, focus 되지 않고 blur되는 경우에 어떻게 처리할 지
  searchInputEl.addEventListener('blur', function(){
    searchEl.classList.remove('focused');
    searchInputEl.setAttribute('placeholder','');
   
  });
  => input창이 줄어들게 되면 추가된 class인 focused는 사라지고,
     placeholder의 '통합검색'이 사라짐

  
  💥 JS에서는 event 속성에 따라 클래스를 추가 및 삭제 시킬 수 있고,
     그러한 class를 스타일화 하기 위해 CSS를 사용


<!--😎😎헤더와 드롭다운- 메인메뉴(1)😎😎-->
* 메인메뉴를 누르면 하위메뉴들이 나타나는 ! = 드롭다운 메뉴
* 따라서, 특정메뉴의 하위메뉴를 두개 만들어서 각각의 내용을 가운데 정렬시켜줄 수 있는
  또 다른 inner 개념을 만들어줌

  <ul class="main-menu">
    <li class="item">
      <div class="item__name">COFFEE</div>
      <div class="item__contents"></div>
    </li>
  </ul> 
  
  main-menu: main-menu의 영역
  item : 그 안의 영역
  item__name: 목록 이름( 언더바 꼭 2개이어야 함)
  item__contents : 목록을 누르면 나타나는 contents

 💥hover을 .item__name에 적용하는 것이 아닌 item에 적용하는 이유?
  : 각각의 item에 마우스를 올리면 이름 부분에 hover효과가 생기는게 맞지만
    결국 그 하위요소가 될 .item_contents에도 영향을 가야하기 때문  
  : 따라서 그 둘을 덮고 있는 부모요소인 item에 hover를 붙여야 함

 * header .main-menu{
  position:absolute;
  /* .main-menu를 부모요소 안에서 원하는 위치에 위치하고자*/
  bottom:0;
  right:0; 
  z-index:1; 

  display: flex;

} 

1) .main-menu의 위치를 부모요소안에서 원하는 위치에 배치되도록 position:absolute설정
2) 부모요소 안에 위치하려는 양 끝값 : bottom: 0 / right:0;
3) z-index:1을 설정하는 이유?
  : main-menu에 마우스를 focus했을 때 내려오는 하단영역의 메뉴가
    웹페이지에 일반적으로 구성된 것을 덮어 보일 수 있도록
    쌓임요소의 순서를 우선순위로 둔 것

  💥 item_ contents 넣는 순서
  
  💥 contents__name / contents_texture의 text를 중앙정렬 될 수 있도록 만들기
  => 필요한 것 : 'inner'라는 class를 가진 요소 
              : 'inner' class를 가지고 있으면 화면의 중앙으로 원하는 만큼의
                 너비를 사용해서  중앙 정렬을 해줄 수 있는 개념
                 <li class="item">
                  <div class="item__name">COFFEE</div>
                  <div class="item__contents">
                    <div class="contents__menu">
                      <div class="inner">COFFEE</div>
                    </div>
                    <div class="contents__texture">
                      <div class="inner">COFFEE</div>
                    </div>
                  </div>
                </li>  
                
  => 이렇듯, 하나의 줄을 viewport를 왼쪽 끝에서 오른쪽 끝까지
     전체 영역을 차지하게 만든 후, 어떤 특정한 내용들을 화면의 중앙으로
     정렬시킬 수 있도록 inner를 사용 (inner라는 단어가 중요한게 아님)          
  
     .inner{
      /* 프로젝트 안에 있는 모든 inner 클래스*/ 
      width:1100px;
      margin:0 auto; /*browser가 자동으로 중앙정렬 시킬 수있도록*/
      /* 대부분의 경우, 가운데로 몰아져 있는 그 영역 안에서 특정한 요소들을 
      '배치'를 통해서 위치를 잡아줄 것이므로 기본적으로
      position을 설정해서 위치상의 '부모요소'가 될 수 있는 relative를 추가해줌*/
      position: relative;
            
    
    }
   프로젝트 안에 있는 모든 inner는 정확한 높이값은 X 
   다만, 정확한 너비값,  margin:auto , position: relative만 있음 
  <!--😎😎헤더와 드롭다운 메인메뉴(2) 😎😎-->
  
  <!--💗드롭다운 메뉴 첫번째 ①💗-->
  <!--HTML구조-->
  <div class="contents__menu">
    <ul class="inner"> <!--20211121-->
      <li>
        <h4>커피</h4>
        <ul>
          <li>스타벅스 원두</li>
          <li>스타버그 비아</li>
          <li>스타벅스 오리가미</li>
        </ul>
      </li>
      <li>
  <!--CSS-->
  header .main-menu .item .item__contents .contents__menu > ul{
    /* .contents__menu > ul : > 자식선택자 사용한 이유
       : .contents__menu 안에는 ul태그가 2개 있음.
          따라서 자식 선택자로 명시하지 않으면 하위 선택자가 되고 결국에는 
          CSS에 적용한 것이 모든 ul태그에 적용돼버림
       : 따라서 여러 ul태그가 하나의 태그에 들어있다면 꼭 자식클래스를 사용하여
         어떤 클래스에 영향을 줄건지를 명시하는게 중요*/
       display: flex;
       padding:20px 0;
   }
   
   header .main-menu .item .item__contents .contents__menu > ul>li{
     /*ul태그는 li태그를 당연히 포함해야 하므로 내부구조를 명확히 해주기 위해서 
       자식클래스를 사용하게 됨*/
      width:220px;
      
     }
   
   header .main-menu .item .item__contents .contents__menu > ul>li h4{
    padding: 3px 0 12px 0;
    font-size: 14px;
    color:#fff;
   }
   
   <!-- header .main-menu .item .item__contents .contents__menu > ul>li ul{
     사용 X
   }-->

   header .main-menu .item .item__contents .contents__menu > ul>li ul li{
    /* 스타벅스 원두 스타벅스 비아....*/
    padding:5px 0;
    font-size:12px;
    color:#999;
    cursor: pointer;;
    /* 마우스를 올리면 마우스 모양에서 손가락 모양으로 변화*/
   }

  💞 header .main-menu .item .item__contents .contents__menu{
    background-color:hotpink;
    height:200px; /* 안에 contents를 넣었으므로 따로 필요치 X*/ => 삭제함
 }
 
 <!--드롭다운 메뉴 두번째 ②-->
 : 드롭다운 배경에는 pattern이 따로 깔려있어야 함 
  <!--HTML구조-->
  <div class="contents__texture">
    <ul class="inner">
      <h4>나와 어울리는 커피 찾기</h4>
      <p>스타벅스가 여러분에게 어울리는 커피를 찾아드립니다.</p>
      <h4>최상의 커피를 즐기는 법</h4>
      <p>여러가지 방법을 통해 다양한 풍미의 커피를 즐겨보세요.</p>
    </ul>
  </div>
  <!--CSS구조-->
  header .main-menu .item .item__contents .contents__texture{
    padding:26px 0; /*내부여백*/
    font-size: 12px;
    background-image: url("/images/main_menu_pattern.jpg"); /*패턴지정*/
  }
  
  header .main-menu .item .item__contents .contents__texture h4 {
    color:#999;
    font-weight: 700;
   
  }
  
  header .main-menu .item .item__contents .contents__texture p {
    color:#669900;
    margin:4px 0 14px; /*top/left,right/bottom*/
   
  }
  
  header .main-menu .item .item__contents .contents__menu > ul>li ul li:hover{
    color:#669900;
  }


  <!--😎😎10.헤더와 드롭다운 메뉴-BEM😎😎-->
💗BEM(Block Element Modifier)💗
: HTML 클래스 속성의 '작명법'
요소__일부분 : Underscore(Lodash) 기호로 요소의 '일부분' 표시
요소-상태    : Hyphen(Dash)기호로 요소의 '상태'를 표시 

ex) <div class="container"> <!--부모-->
      <div class="name"></div> <!--자식-->
      <div class="item"> <!--자식(형제)-->
        <div class="name"></div> <!--item의 자식-->
      </div>
   </div>

   위 코드의 문제점: .container의 자식요소인 name에 스타일 지정
                   .container .name {

                   }
                   => 이 방식으로 쓰게 되면 item요소의 name마저도 
                      의도치 않게 스타일이 부여됨
                   => 이렇듯 단순한 class명은 중복될 여지가 있음

  ex) BEM방식 적용(요소__일부분)
   <div class="container">
     <div class="container__name"></div>
     <div class="item">
       <div class="itme__name"></div>
     </div>
   </div>

   <div class="container__name"></div>
   : 이 div요소는 container의 일부분이고,
     일부분의 class이름이 'name'이란 뜻
   : 이러한 방식은 굳이 HTML을 확인하지 않아도 어떤 class의 
    일부분이구나를 쉽게 파악할 수 있음

  ex) <div class="btn primary"></div> <!--일반버튼-->
      <div class="btn success"></div> <!--무엇인가 완료된 버튼-->
      <div class="btn error"></div> <!--에러제어 버튼-->

      : 여기서 primary / success / error는 버튼의 상태 의미하는 클래스
      : 하지만 primary / success / error는 btn 클래스와 동떨어진 이름처럼 보임
       => 요소 -- 상태 방식으로 변경 ▽

  ex) BEM방식 적용(요소--상태)

  ex) <div class="btn btn---primary"></div> <!--버튼은 버튼인데 상태가 primary-->
      <div class="btn btn--success"></div> 
      <div class="btn btn--error"></div>

      => 클래스의 이름만 보고도 어떤 역할을 할 것인지 알 수 있음

  <!--😎😎11. 헤더와 드롭다운 메뉴- 전역배지(GSAP)-1😎😎-->    
  : 오른쪽에 붙어있는 배지
  : 스크롤 될 때 일정 영역까지 같이 내려갔다 영역 넘으면 사라짐
  
  💗position: fixed를 header에 한 이유
  : header부분이 브라우저의 viewport를 기준으로 고정되어 있도록 하기 위해서
  
  header{
    background-color: #f6f5f0;
    border-bottom: 1px solid #c8c8c8;
    /* position:relative; */
    position:fixed; /*브라우저의 viewport를 기준으로 배치하겠다*/
    top:0px;
    
  }

  >>> 결과는 웹페이지 너비에 여백이 생겨버림
  WHY? viewport를 기준으로 요소가 배치되는 것이기 때문에 header요소의 가로너비는
      기본값이 auto이고, 브라우저가 자동으로 계산하면서 요소의 너비를 최대한 많이 사용하려 하지 못하고
      화면의 너비를 '최소한'으로 실행하려고 함
  >>> 이런 현상은 position:fixed와 absolute에서 많이 나타남
      일반적으로 block요소는 가로너비가 최대한 늘어나려고 시도하지만,
      position이 fixed와 absolute로 부여되어져 있는 너비는 가로너비가 최소한으로 
      줄어드려고 시도
  >>> width를 auto에서 100%로 수정하는게 해결방안!    
 
   ✔ header태그에 position:relative를 넣었던 이유
   : .badges의 위치상 부모요소로서 '기준'이 될 수 있도록 넣은 것 뿐.
     position:fixed를 넣었으므로 필요 X  

  💗일정영역 이상을 벗어나게끔 scroll을 움직였을 때 badget가 사리지도록 구현💗
  => javascript
  (화면의 scroll값이 일정값 이상보다 커지면 badges가 사라지도록 해보자 )

  window.addEventListener('scroll',function(){
    console.log('scroll');
    /* 1) window객체 : 우리 프로젝트가 출력되고 있는 화면 자체
       2) 화면자체에 scroll 이벤트를 추가하여 화면이 스크롤 되면,
          function()을 실행하겠다. */
     /* 결과 => 스크롤할때마다 반응을 하는데, 
               즉, 스크롤할 때마다 실행되는 함수가 굉장히 많음을 의미
               사이트의 내용이 많아지면 많아질수록 프로젝트 자체가 무거워짐
               => 스크롤할 대 부담이 생기면 화면이 버벅이는 문제 발생 */
     /* 따라서, 스크롤할때 실행되는 함수의 수를 외부에서 가지고 올 수 있는 
        JS 라이브러리를 통해서 제어할 것임
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js" integrity="sha512-WFN04846sdKMIP5LKNphMaWzU7YpMyCU245etK3g/2ARYbPK9Ub18eG+ljU96qKRCWh+quCY7yefSmlkQw1ANQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        => Google : lodash cdn
        => 태그 복사해서 HTML head 태그에 붙여넣기*/
        
        
        // scroll을 일정부분이상 내렸을 때 badges 사라지게 하기*/
        const badgeEl = document.querySelector('header .badges');
        
        /*window : 프로젝트가 나타나있는 브라우저 하나의 탭(화면자체)*/ 
        
        window.addEventListener('scroll',_.throttle(function(){
          console.log(window.scrollY);
          if(window.scrollY>500){
             //배지 숨기기
             gsap.to(badgeEl, .6,{
               opacity:0,
               display:'none'
             })
             /*grap.to(요소,지속시간, 옵션*/
            /* 옵션 : 사용가능한 JS라이브러리 등은 옵션으로 '객체데이터' 사용*/
          }else{
           // 배지 보이기
           gsap.to(badgeEl,.6,{
             opacity:1,
             display:'block'
           }) 
          }
          
        },300))
        
        /* _.throttle(함수,시간); 
         /* 1) _.throttle : loadash라이브러리❗를 통해서 이러한 명령을 쓸 수 있게 script태그를
           연결함으로 해서 이미 등록이 됨
            2)  300ms = 0.3s(1000ms = 1s)
            3) 윈도우부분에 scroll 이벤트를 이용해서 scroll을 하면 함수 수십개가 한 번에
               실행되는데,  그것을 0.3s 단위로 부하를 줘서 함수가 우르르 실행되는 것을 방지
               => 결과: 스크롤할때 몇백개씩 출력이 되던 전과 달리 출력 수가 5개를 넘지 않음*
            ==>  화면이 스크롤될 때 시행되는 함수의 개수를 _.throttle라는 메소드, 즉,
                 기능을 실행해서 일정시간에 한 번씩만 실행되도록 제한을 걸음     
            ==> _.throttle은 스크롤이벤트를 통해서 작업을 할 때 굉장히 많이 사용됨
                why? 화면을 스크롤 할 때마다 연결되어져있는 익명함수가 굉장히 많은 횟수에 걸쳐서 실행되기 때문 */
        
        /* window.scrollY => scroll위치를 숫자로 알 수 있음
           만약 window.scrollY의 값이 500보다 크면 badgeel.style.display = 'none', 즉 배지를 안보이게 해라
           그렇지 않으면 보이게 해라
        
           => 결과로 보이고 안보이고는 하지만, 생기고 사라지는 과정이 너무 부자연스러움
          : 좀 더 자연스럽게 요소를 제어해줄 수 있는 JS 애니메이션 라이브러리 사용❗
          : gsap cdn❗에서 HTML태그 복붙
          <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.8.0/gsap.min.js" integrity="sha512-eP6ippJojIKXKO8EPLtsUMS+/sAGHGo1UN/38swqZa1ypfcD4I0V/ac5G3VzaHfDaklFmQLEs51lhkkVaqg60Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

          : gsap에서 제공하는 애니메이션 처리방법 중에 'to'라는 기능으로 에니메이션 추가
          : to()에서 옵션 영역은 'css속성과 값들을 입력할 수 있음. 다만 Css와 조금 다른점이 있다면 
            문자값은 '' 를 사용해야 함*/
        
        /* 👀Problem
        : gsap.to(요소,시간,옵션{})를 이용해서 처리는 했으나, 
          사실 badge가 보이고 안보이고 해도 badge의 html 특성은 지정한 
          그 자리에 그대로 남아있음
        : 즉, badge에 지정했던 css요소인 cursor:pointer효과가 보이지 않아도
          나타나게 됨
        : opacity를 이용해서 효과를 주는건 중요하지만, 실제로 그 자리에 없어야 하는게 맞음
        => display:'none' 속성을 사용하여 아예 없어지게 하면 됨
        : opacity 속성처럼 값을 숫자로 입력하는 속성들은, 전환효과(transition 속성 or GSAP 라이브러리 등)을 통해
          요소의 전/후 상태를 중간 숫자의 값으로 자연스럽게 만들어 줄 수 있지만,
          idsplay속성처럼 값이 숫자가 아닌 속성은 전/후 상태의 중간값이 존재하지 않기 때문에,
          자연스러운 전환효과를 적용할 수 없음*/

   
<!--😎😎13.순차적 애니메이션-전역 버튼 스타일(1)😎😎-->
:header 밑에 있는 visual영역 작업
:section- 하나의 줄 영역을 전부 다 차지하고 있는 영역
        - 사이트를 이루고 있는 하나의 계층
        - 기능적으로 특별히 동작하는 것은 X
          단지, 명시적으로 이 태그의 영역이 section영역임을 의미함
: 이미지가 하나씩 순차적으로 나타나는 작업 - JavaScript이용
<!--html-->
<section class="visual">
  <div class="inner">
    <!--가운데 정렬을 위한 inner 필수 추가-->

    <div class="title">
      <!--이미지의 대체 텍스트가 명확하지 않다면, 이미지에 있는 텍스트를 그대로 옮겨 적기 -->
      <img src="./images/visual_title.png" alt="STARBUCKS DELIGHTFUL START TO THE YEARS"/>
      <a href="javascript:void(0)" class="btn">자세히 보기</a>  
    </div>

    <img src="./images/visual_cup1.png" alt="new OATMEAL LATTE" class="cup1 image"/>
    <img src="./images/visual_cup1_text.png" alt="오트밀 라떼" class="cup1 text"/>
    <img src="./images/visual_cup2.png" alt="new STARBUCKS CARAMEL CRUMBLE MOCHA" class="cup2 image"/>
    <img src="./images/visual_cup2_text.png" alt="스타벅스 카라멜 크럼블 모카" class="cup2 text">
    <img src="./images/visual_spoon.png" alt="Spoon" class="spoon">
  
  
  </div>
</section>
<!--css-->
이따 복붙하기


<!--😎😎순차적 애니메이션-순차적으로 요소 보이기😎😎-->
: image가 시간차로 나타나도록 !
: 전체적으로 이미지를들 안보이게 만든 후에 JS로 구현


<!--😎😎요소 슬라이드-- 공지사항😎😎-->

     
<section class="notice">

  <div class="notice-line">
  <div class="bg-left"></div><!--배경 왼쪽-->
  <div class="bg-right"></div><!--배경 오른쪽-->
  <div class="inner"></div><!--notice 라인을 중앙으로 몰아 넣어줄 수 있는 부분-->
  </div>

</section>


<!--😎😎요소 슬라이드-슬라이드(swiper)😎😎-->
:JS 라이브러리 / 구글검색- swiperJs
:get started에서 cdn복붙(CSS파일, JS파일 둘 다 필요)
:demo 부분 가면 어떤 swiper를 사용할 수 있는가 예시가 나와있음

* swiper
: Add Swiper HTML Layout - HTML구조를 어떻게 작성해야 적용되는지를 알 수 있음
 1) Slider main container
 :Slider의 메인이 되는 container을 먼저 잡아야 함
 2) Additional required wrapper 
 : wrapper라는 이름을 가진 class가 필요하다
 => 그 안에는 실제 slide가 되는 요소들을 적어줌
 ex) <div class="swrper-slide">slide1</div>
    <div class="swrper-slide">slide2</div>
     <div class="swrper-slide">slide3</div>
=> slide-contaienr & slide-wrapper & swiper-slide만 있으면 
   정상적으로 출력됨 

 <!-- 3) If we need pasgination
 4) If we need navigation buttons
 5) If we need scrollbar -->

 <!--😎😎18. 요소 슬라이드 - 가운데 배치😎😎-->
 : 공지사항 아래칸에서 작동하고 있는 슬라이도 역시 swiper 라이브러리를 이용한 것임
 1. 화살표를 누르면 슬라이드가 됨
 2. 자세히 보기 버튼
 3. 슬라이드 넘어가는 페이지를 원으로 표현
 4. 화면을 확대해도 이미지 가운데 배치

특징 : 제시된 슬라이드 이미지는 3개
       그 중 가운데 이미지는 불투명
       양 옆의 이미지는 약간 투명
       => 즉 슬라이드에서 첫번째 이미지는 
          '가운데' 이미지
          (width 819px)
       => 이미지 사이 공간은 10px 
       >>>  swiper-container영역의 가로너비 = 819px *3 + (10*2
       >>> 이 계산으로 나오는 결과같은 경우에는 '브라우저'가 자동으로 
           계산할 수 있는 방법을 도입해야 함(css - clac() )
       >>> calc는 %, px등 어떤 단위도 계산 가능 ex) calc(100%- 50px)     
  
       
  <!--😎😎19. 요소 슬라이드 - 슬라이드 영역 토글 😎😎-->
: h2 태그로 만든 '스타벅스 프로모션' 의 inner_right부분의 안쪽에
'toggle-promotion'이라는 class를 가진 div요소가 있음
: 이 요소를 클릭하면 하단에 만든 promotion영역 전체를 닫거나 여는 UI작업을 
  할 것임  
  
  
 <!--😎😎22. 유튜브 영상 배경 - 리워즈😎😎-->
 <!--😎😎23. 유튜브 영상 배경 - Youtube iFrame API(1)😎😎-->
 1) padding- 요소의 크기가 늘어날 수 있는 구조
           - padding-top 요소를 %로 지정을 하게되면, (%는 상대적 기준)
             예를 들어 무엇인가를 기준으로 50% 로 지정을 하였는데, 
             그것은 item의 부모요소의 가로너비만큼에 해당하는 50%의 너비를
            가짐
            (ex) 부모요소의 너비:500px / 자식요소의 padding-top: 50% => 250px)
            ==> 부모요소 & 자식요소 하나를 가지고서 
                몇 대 몇 비율의 가로너비, 세로너비를 가지고 있는 요소의 크기를
                만들어 낼 수 있음  
            ==> 이런 방법을 유튜브 등의 영상을 삽입할 때 유용하게 사용 가능
            ==> 유튜브 등의 영상의 일반적인 비율 => (가)16: (세)9 
            ex)  100% : 56.25% = 16 : 9       
                : 어떤 너비값을 가지고 있어도 56.25%만 기억하면 16:9 비율 완성

 2) class VS ID
 공통점 : 고유의 이름
 차이점: class - 이름 중복 가능
          ID  - 중복X    
          
 <!--😎😎24. 유튜브 영상배경 - Youtube iframe API(2)😎😎--> 
 구글검색 - youtube iframe API  => iframe 삽입에 대한 YouTube Player API 참조 문서
                               => [시작하기] - HTML 예시 문서

 <!--😎😎25.유튜브 영상 배경- 반복 애니메이션😎😎-->                              
: 유튜브 영역에서 둥둥 떠다니는 요소 만들기  

<!--😎😎고정 이미지 배경😎😎-->

<!--😎😎3D 애니메이션😎😎-->
패럴렉스
요소의 앞면과 뒷면을 교차적으로 출력하면서 3차원의 애니메이션 효과 구현
 

<!--😎😎28. 스크롤 위치 계산- 애니메이션(1)😎😎-->
: 만들고 있는 화면을 위에서부터 아래로 스크롤하면
  화면에 보이고 있지 않던 요소들이 나타나는 것을 볼 수 있음
: 이러한 방식을 각각의 section부분이 화면에 보이는지 그렇지 않은지를
  파악해서 화면에 보이면 그 안에있는 내용들을 animation처리할 수 있도록
  작업해줄 예정
  =>라이브러리 
    구글검색 : scrollMagic cdn
  => 링크 복사 : <script src="https://cdnjs.cloudflare.com/ajax/libs/ScrollMagic/2.0.8/ScrollMagic.min.js" integrity="sha512-8E3KZoPoZCD+1dgfqhPbejQBnQfBXe8FuwL4z/c8sTrgeDMFEnoyTlH3obB4/fV+6Sg0a0XF+L/6xS4Xx1fUEg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
 
<!--😎😎29. 스크롤 위치 계산- 애니메이션(2) 😎😎--> 
 <!--SEASON PRODUCT 부분 중-->
<div class="more back-to-position to-left">
  <a href="javascript:void(0)" class="btn">자세히 보기</a>
</div> 
: 자세히 보기가 있는 a태그를 굳이 div.more 로 감싼 이유?
: back-to-position으로 지정할 부분에 transition을 1초로 설정해야 함
: 그리고 btn에도 역시 tansition 0.4s로 설정이 되어있음 
: 만약에 둘을 일치선택자로 해놓고 transition 설정을 따로 해놓으면 두 개의 
   transtion 속성 중 하나는 무시될 수 있기 때문에 a태그 밖을 div로 감싸서
   그 문제점을 해결한 것

<!--😎😎30. 다중 요소 슬라이드😎😎-->
: 다중의 이미지들을 슬라이드 하는 구조